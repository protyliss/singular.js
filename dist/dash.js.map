{"version":3,"sources":["dash.js"],"names":["dash","window","document","undefined","fragment","HTML","HEAD","START_PATH","ORIGIN","htmlSelectors","_location","location","href","origin","FROM","Array","from","READY_CALLBACKS","LOAD_CALLBACKS","UNLOAD_CALLBACKS","CONFIGURE","development","classSelectors","enableKeepHtml","enableKeepStyles","enableSearchString","enableHashString","FRAGMENT_HTML","createDocumentFragment","fragmentHtml","createElement","appendChild","_createClass","Page","_classCallCheck","this","_defineProperty","State","START_HTML","SERIES_CALLBACKS","FETCH_CONTROLLER","enter","callback","route","LOADED","styleElements","getStyleElement","scriptElements","getScriptElement","styles","current","length","BODY","getAbsoluteUrl","style","unload","src","script","scripts","RENDERED_SCRIPTS","startPage","PAGES","CURRENT_PATH","title","html","store","links","anchor","getAttribute","startsWith","setAttribute","callbacks","exitCallbacks","concat","end","reason","console","warn","abort","replace","substring","indexOf","getHref","cache","pushState","request","then","render","rawHtml","innerHTML","getElementsByTagName","innerText","classMap","selector","className","page","result","getStyleHref","target","querySelector","parentNode","removeChild","scrollTo","targetHTML","outerHTML","classes","parse","apply","arguments","AbortController","fetch","signal","responseText","catchError","response","text","hashIndex","index","searchIndex","DOMException","to","children","elements","imports","Promise","resolve","removeStyles","renderedStyleHrefs","Object","keys","RENDERED_STYLES","link","promise","getScriptSrc","_addScript","addScript","append","container","querySelectorAll","node","attribute","URL","onLoad","series","parent","replaceChild","prepares","PARALLEL_CALLBACKS","all","catchReload","onLoading","enterCallbacks","addStyle","configure","key","onload","resolver","onerror","rel","async","ready","parallel","load","history","addEventListener","event","tagName","_dashAnchor","closest","download","rawHref","_node4$dataset","dataset","outlet","inlineOutlet","split","stopPropagation","state","documentElement","head","body","visibility"],"mappings":"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","file":"dash.js","sourcesContent":["\"use strict\";\nconst dash = (function (window, document, undefined) {\n    const { href: START_PATH, origin: ORIGIN } = location;\n    const { from: FROM } = Array;\n    const READY_CALLBACKS = [];\n    const LOAD_CALLBACKS = [];\n    const UNLOAD_CALLBACKS = [];\n    const CONFIGURE = {\n        development: false,\n        htmlSelectors: null,\n        classSelectors: null,\n        enableKeepHtml: false,\n        enableKeepStyles: false,\n        enableSearchString: false,\n        enableHashString: false\n    };\n    const FRAGMENT_HTML = (() => {\n        const fragment = document.createDocumentFragment();\n        const fragmentHtml = document.createElement('html');\n        fragment.appendChild(fragmentHtml);\n        return fragmentHtml;\n    })();\n    let HTML;\n    let HEAD;\n    let BODY;\n    let START_HTML;\n    let SERIES_CALLBACKS = [];\n    let PARALLEL_CALLBACKS = [];\n    let RENDERED_STYLES = {};\n    let RENDERED_SCRIPTS = {};\n    let LOADED = false;\n    let CURRENT_PATH = START_PATH;\n    let FETCH_CONTROLLER;\n    class Page {\n        title;\n        styles;\n        scripts;\n        enterCallbacks = [];\n        exitCallbacks = [];\n        classes;\n        html;\n    }\n    class State {\n        dash;\n        constructor(href) {\n            this.dash = {\n                href\n            };\n        }\n    }\n    const PAGES = {\n        [START_PATH]: new Page\n    };\n    /**\n     * @alias dash.enter\n     * @param callback\n     */\n    function dash(callback) {\n        return dash.enter(callback);\n    }\n    /**\n     * Set Configure\n     * @param configure\n     */\n    dash.configure = function (configure) {\n        if (configure.htmlSelectors) {\n            if (typeof configure.htmlSelectors === 'string') {\n                configure.htmlSelectors = [configure.htmlSelectors];\n            }\n            if (configure.htmlSelectors.indexOf('body') > -1) {\n                configure.htmlSelectors = null;\n            }\n        }\n        if (configure.classSelectors) {\n            if (typeof configure.classSelectors === 'string') {\n                configure.classSelectors = [configure.classSelectors];\n            }\n        }\n        const keys = Object.keys(configure);\n        let current = keys.length;\n        while (current-- > 0) {\n            const key = keys[current];\n            CONFIGURE[key] = configure[key];\n        }\n        return dash;\n    };\n    /**\n     * Set Series Callback for Bootstrap\n     * @description\n     *   Callbacks Call as Single Thread\n     *   If Previous Callback to failed, Does not Move to Next Callback.\n     * @param callback\n     */\n    dash.series = function (callback) {\n        SERIES_CALLBACKS[SERIES_CALLBACKS.length] = callback;\n        return dash;\n    };\n    /**\n     * Set Parallel Callback for Bootstrap\n     * @description\n     *   Callbacks Call as Multiple Thread\n     * @param callback\n     */\n    dash.parallel = function (callback) {\n        PARALLEL_CALLBACKS[PARALLEL_CALLBACKS.length] = callback;\n        return dash;\n    };\n    /**\n     * Add External Stylesheet to <HEAD> Using <LINK>\n     * @param href\n     */\n    dash.addStyle = function (href) {\n        const link = document.createElement('link');\n        return {\n            link,\n            promise: new Promise((resolve) => {\n                const resolver = () => resolve();\n                link.onload = resolver;\n                link.onerror = resolver;\n                link.rel = 'stylesheet';\n                HEAD.append(link);\n                link.href = href;\n            })\n        };\n    };\n    /**\n     *  Add External Stylesheet to <HEAD> Using <SCRIPT>\n     * @param src\n     * @param async\n     */\n    dash.addScript = function (src, async = true) {\n        const script = document.createElement('script');\n        return {\n            script,\n            promise: new Promise((resolve) => {\n                const resolver = () => resolve();\n                script.onload = resolver;\n                script.onerror = resolver;\n                script.async = async;\n                HEAD.append(script);\n                script.src = src;\n            })\n        };\n    };\n    /**\n     * Run Once in Declared Document after DOMContentLoaded\n     * @param callback\n     */\n    dash.ready = function (callback) {\n        READY_CALLBACKS[READY_CALLBACKS.length] = callback;\n        if (LOADED) {\n            callback(BODY);\n        }\n        return dash;\n    };\n    /**\n     * Run Everytime in Every Document after DOMContentLoaded\n     * @param callback\n     */\n    dash.load = function (callback) {\n        LOAD_CALLBACKS[LOAD_CALLBACKS.length] = callback;\n        if (LOADED) {\n            callback(BODY);\n        }\n        return dash;\n    };\n    dash.unload = function (callback) {\n        UNLOAD_CALLBACKS[UNLOAD_CALLBACKS.length] = callback;\n        return dash;\n    };\n    /**\n     * Run Everytime in Declared Document after DOMContentLoaded\n     * @param callback\n     */\n    dash.enter = function (callback) {\n        const store = PAGES[CURRENT_PATH].enterCallbacks;\n        store[store.length] = callback;\n        if (LOADED) {\n            callback(BODY);\n        }\n        return dash;\n    };\n    /**\n     * Run Everytime in Declared Document after beforeunload\n     * @param callback\n     */\n    dash.exit = function (callback) {\n        const store = PAGES[CURRENT_PATH].exitCallbacks;\n        store[store.length] = callback;\n        return dash;\n    };\n    /**\n     * Move to Other Document\n     * @param href\n     * @param htmlSelectors\n     */\n    dash.route = function (href, htmlSelectors) {\n        try {\n            route(href, htmlSelectors);\n        }\n        catch (reason) {\n            console.warn(reason);\n            if (!CONFIGURE.development) {\n                location.replace(href);\n            }\n            return null;\n        }\n        history.pushState(new State(href), href, href);\n    };\n    /**\n     * Signal for DOM Changed by any codes\n     * @param target\n     */\n    dash.changed = function (target = BODY) {\n        const end = LOAD_CALLBACKS.length;\n        let current = -1;\n        while (++current < end) {\n            LOAD_CALLBACKS[current](target);\n        }\n        return dash;\n    };\n    function route(href, htmlSelectors) {\n        const styleElements = getStyleElement(HTML);\n        const scriptElements = getScriptElement(HTML);\n        const styles = [];\n        const scripts = [];\n        let current = styleElements.length;\n        while (current-- > 0) {\n            const style = styleElements[current];\n            const href = getAbsoluteUrl(style, 'href');\n            styles[styles.length] = href;\n            RENDERED_STYLES[href] = style;\n        }\n        current = scriptElements.length;\n        while (current-- > 0) {\n            const script = scriptElements[current];\n            const src = getAbsoluteUrl(script, 'src');\n            scripts[scripts.length] = src;\n            RENDERED_SCRIPTS[script.src] = script;\n        }\n        const startPage = PAGES[CURRENT_PATH];\n        startPage.title = document.title;\n        startPage.styles = styles;\n        startPage.scripts = scripts;\n        startPage.html = START_HTML;\n        START_HTML = null;\n        const { links } = document;\n        current = links.length;\n        while (current-- > 0) {\n            const anchor = links[current];\n            const href = anchor.getAttribute('href');\n            if (!href || !(href.startsWith('./') || href.startsWith('../'))) {\n                continue;\n            }\n            anchor.setAttribute('href', anchor.href);\n        }\n        // @ts-ignore\n        return (route = function (href, htmlSelectors) {\n            // console.debug(`[dash] ${href}`);\n            if (LOADED) {\n                const callbacks = PAGES[CURRENT_PATH].exitCallbacks.concat(UNLOAD_CALLBACKS);\n                const end = callbacks.length;\n                let current = -1;\n                try {\n                    while (++current < end) {\n                        callbacks[current]();\n                    }\n                }\n                catch (reason) {\n                    console.warn(reason);\n                }\n            }\n            else if (FETCH_CONTROLLER) {\n                FETCH_CONTROLLER.abort();\n            }\n            if (!htmlSelectors) {\n                htmlSelectors = CONFIGURE.htmlSelectors;\n            }\n            window.scrollTo(0, 0);\n            document.title = href.substring(href.indexOf(':') + 3);\n            LOADED = false;\n            CURRENT_PATH = getHref(href);\n            const cache = PAGES[CURRENT_PATH];\n            if (cache) {\n                if (CONFIGURE.enableKeepHtml) {\n                    render(cache);\n                }\n                else {\n                    request(href)\n                        .then(html => {\n                        cache.html = html;\n                        render(cache);\n                    });\n                }\n            }\n            else {\n                request(href)\n                    .then(html => {\n                    parse(href, html, htmlSelectors);\n                });\n            }\n        }).apply(this, arguments);\n        function request(href) {\n            FETCH_CONTROLLER = new AbortController();\n            return fetch(href, {\n                signal: FETCH_CONTROLLER.signal\n            })\n                .then(responseText)\n                .catch(catchError);\n        }\n        function responseText(response) {\n            return response.text();\n        }\n        function catchError(reason) {\n            console.warn(reason);\n            if (!(reason instanceof DOMException)) {\n                console.warn(reason);\n            }\n        }\n    }\n    function parse(href, rawHtml, htmlSelectors) {\n        const page = getPage(rawHtml, href, htmlSelectors);\n        PAGES[CURRENT_PATH] = page;\n        render(page);\n    }\n    function getHref(href) {\n        if (!CONFIGURE.enableHashString) {\n            const index = href.indexOf('#');\n            if (index > -1) {\n                href = href.substring(0, index);\n            }\n        }\n        if (!CONFIGURE.enableSearchString) {\n            const searchIndex = href.indexOf('?');\n            const hashIndex = href.indexOf('#');\n            if (searchIndex > -1) {\n                href = (href.substring(0, searchIndex)\n                    + (hashIndex > -1 ?\n                        href.substring(hashIndex) :\n                        ''));\n            }\n        }\n        return href;\n    }\n    function getPage(rawHtml, href, htmlSelectors) {\n        FRAGMENT_HTML.innerHTML = rawHtml;\n        const title = (FRAGMENT_HTML.getElementsByTagName('TITLE')[0] || {}).innerText || href;\n        let current;\n        const { classSelectors } = CONFIGURE;\n        let classMap = null;\n        if (classSelectors) {\n            classMap = {};\n            current = classSelectors.length;\n            while (current-- > 0) {\n                const selector = classSelectors[current];\n                classMap[selector] = (FRAGMENT_HTML.getElementsByTagName(selector)[0] || {}).className || '';\n            }\n        }\n        const styleElements = getStyleElement(FRAGMENT_HTML);\n        const scriptElements = getScriptElement(FRAGMENT_HTML);\n        const styles = getStyleHref(styleElements);\n        const scripts = getScriptSrc(scriptElements);\n        current = scriptElements.length;\n        while (current-- > 0) {\n            const script = scriptElements[current];\n            if (script?.parentNode) {\n                script.parentNode.removeChild(script);\n            }\n        }\n        let html;\n        if (htmlSelectors) {\n            const targetHTML = [];\n            let current = htmlSelectors.length;\n            while (current-- > 0) {\n                const target = FRAGMENT_HTML.querySelector('#' + htmlSelectors[current]);\n                if (target) {\n                    targetHTML[targetHTML.length] = target.outerHTML;\n                }\n            }\n            html = targetHTML.join('');\n        }\n        else {\n            html = FRAGMENT_HTML.outerHTML;\n        }\n        const page = new Page;\n        page.title = title;\n        page.title = title;\n        page.styles = styles;\n        page.scripts = scripts;\n        page.classes = classMap;\n        page.html = html;\n        return page;\n    }\n    function render(page) {\n        const { title, styles, scripts, classes, html } = page;\n        if (title) {\n            document.title = title;\n        }\n        const { htmlSelectors, classSelectors } = CONFIGURE;\n        if (classSelectors && classes) {\n            let current = classSelectors.length;\n            while (current-- > 0) {\n                const selector = classSelectors[current];\n                const target = HTML.querySelector(selector);\n                if (target) {\n                    target.className = classes[selector];\n                }\n            }\n        }\n        FRAGMENT_HTML.innerHTML = html;\n        if (htmlSelectors) {\n            let current = htmlSelectors.length;\n            while (current-- > 0) {\n                const selector = htmlSelectors[current];\n                const from = FRAGMENT_HTML.querySelector('#' + selector);\n                const to = BODY.querySelector('#' + selector);\n                if (from && to) {\n                    const parent = to.parentNode;\n                    parent.replaceChild(from, to);\n                }\n            }\n        }\n        else {\n            BODY.innerHTML = '';\n            BODY.append(...(FRAGMENT_HTML.getElementsByTagName('BODY')[0]\n                || FRAGMENT_HTML).children);\n        }\n        FRAGMENT_HTML.innerHTML = '';\n        const { addScript, addStyle } = dash;\n        const elements = [];\n        const imports = [Promise.resolve()];\n        const removeStyles = [];\n        let end;\n        let current;\n        if (!CONFIGURE.enableKeepStyles) {\n            const renderedStyleHrefs = Object.keys(RENDERED_STYLES);\n            current = renderedStyleHrefs.length;\n            while (current-- > 0) {\n                let href = renderedStyleHrefs[current];\n                if (styles.indexOf(href) > -1) {\n                    continue;\n                }\n                // RENDERED_STYLES[href].disabled = true;\n                removeStyles[removeStyles.length] = RENDERED_STYLES[href];\n                delete RENDERED_STYLES[href];\n            }\n        }\n        // add external stylesheet\n        end = styles.length;\n        current = -1;\n        while (++current < end) {\n            const href = styles[current];\n            if (RENDERED_STYLES[href]) {\n                //     RENDERED_STYLES[href].disabled = false;\n                continue;\n            }\n            const { link, promise } = addStyle(href);\n            RENDERED_STYLES[href] = link;\n            imports[imports.length] = promise;\n            elements[elements.length] = link;\n        }\n        // add external script\n        end = scripts.length;\n        current = -1;\n        while (++current < end) {\n            const src = scripts[current];\n            if (RENDERED_SCRIPTS[src]) {\n                continue;\n            }\n            const { script, promise } = addScript(src);\n            RENDERED_SCRIPTS[src] = script;\n            imports[imports.length] = promise;\n            elements[elements.length] = script;\n        }\n        if (elements.length) {\n            HEAD.append(...elements);\n        }\n        Promise.all(imports)\n            .then(() => {\n            let current = removeStyles.length;\n            while (current-- > 0) {\n                const link = removeStyles[current];\n                link.parentNode.removeChild(link);\n            }\n            onLoad();\n        });\n    }\n    function getStyleElement(container) {\n        const result = [];\n        const styles = FROM(container.querySelectorAll('link[rel=stylesheet]'));\n        const end = styles.length;\n        let current = -1;\n        while (++current < end) {\n            const link = styles[current];\n            if (link.getAttribute('href') && link.href.startsWith(ORIGIN)) {\n                result[result.length] = link;\n            }\n        }\n        return result;\n    }\n    function getStyleHref(styles) {\n        const result = [];\n        let current = styles.length;\n        while (current-- > 0) {\n            result[result.length] = getAbsoluteUrl(styles[current], 'href');\n        }\n        return result;\n    }\n    function getScriptElement(container) {\n        const result = [];\n        const scripts = container.querySelectorAll('script[src]');\n        const end = scripts.length;\n        let current = -1;\n        while (++current < end) {\n            const script = scripts[current];\n            if (script.getAttribute('src') && script.src.startsWith(ORIGIN)) {\n                result[result.length] = script;\n            }\n        }\n        return result;\n    }\n    function getScriptSrc(scripts) {\n        const result = [];\n        let current = scripts.length;\n        while (current-- > 0) {\n            result[result.length] = getAbsoluteUrl(scripts[current], 'src');\n        }\n        return result;\n    }\n    function getAbsoluteUrl(node, attribute) {\n        return '' + (new URL(node.getAttribute(attribute), CURRENT_PATH));\n    }\n    function onLoad() {\n        // console.debug('[dash] before load');\n        const end = SERIES_CALLBACKS.length;\n        let current = -1;\n        let series = Promise.resolve();\n        while (++current < end) {\n            const callback = SERIES_CALLBACKS[current];\n            series = series.then(() => callback());\n        }\n        const prepares = [series];\n        current = PARALLEL_CALLBACKS.length;\n        while (current-- > 0) {\n            prepares[prepares.length] = PARALLEL_CALLBACKS[current]();\n        }\n        SERIES_CALLBACKS = [];\n        PARALLEL_CALLBACKS = [];\n        Promise.all(prepares)\n            .then(onLoading)\n            .catch(catchReload);\n    }\n    function onLoading() {\n        // console.debug('[dash] after load');\n        HTML.style.visibility = 'inherit';\n        try {\n            onLoaded();\n        }\n        catch (reason) {\n            console.warn(reason);\n        }\n    }\n    function catchReload(reason) {\n        console.warn(reason);\n        if (!CONFIGURE.development) {\n            location.reload();\n        }\n    }\n    function onLoaded(changedElement = BODY) {\n        // console.debug('[dash] Loaded');\n        LOADED = true;\n        const store = PAGES[CURRENT_PATH];\n        const callbacks = READY_CALLBACKS.concat(LOAD_CALLBACKS, store.enterCallbacks);\n        const end = callbacks.length;\n        let current = -1;\n        while (++current < end) {\n            callbacks[current](changedElement);\n        }\n    }\n    addEventListener('click', function onClick(event) {\n        let node = event.target;\n        const { tagName } = node;\n        if (tagName === 'BODY') {\n            return false;\n        }\n        if (tagName !== 'A') {\n            if (node?._dashAnchor === false) {\n                return true;\n            }\n            const anchor = node.closest('a');\n            if (!anchor || !anchor.href) {\n                node._dashAnchor = false;\n                return true;\n            }\n            node = anchor;\n        }\n        const { href } = node;\n        const rawHref = node.getAttribute('href');\n        if (!href.startsWith(ORIGIN)\n            || node.download\n            || (rawHref && rawHref.startsWith('#'))) {\n            node._dashAnchor = false;\n            return true;\n        }\n        node._dashAnchor = node;\n        const inlineOutlet = node?.dataset?.outlet;\n        dash.route(node.href, inlineOutlet ? inlineOutlet.split(',') : undefined);\n        event.stopPropagation();\n        event.preventDefault();\n        return false;\n    });\n    addEventListener('popstate', function onPopstate(event) {\n        const { state } = event;\n        if (state && state.dash) {\n            route(state.dash.href);\n        }\n        return true;\n    });\n    addEventListener('DOMContentLoaded', function onDOMContentLoaded() {\n        HTML = document.documentElement;\n        HEAD = document.head;\n        BODY = document.body;\n        START_HTML = HTML.outerHTML;\n        CURRENT_PATH = getHref(START_PATH);\n        if (CURRENT_PATH !== START_PATH) {\n            PAGES[CURRENT_PATH] = PAGES[START_PATH];\n            delete PAGES[START_PATH];\n        }\n        HTML.style.visibility = 'hidden';\n        onLoad();\n    });\n    return dash;\n})(window, document);\n"]}