{"version":3,"sources":["singular.js"],"names":["singular","window","document","undefined","ABORTER","_location","location","START_PATH","href","ORIGIN","origin","FROM","Array","from","READY_CALLBACKS","LOAD_CALLBACKS","UNLOAD_CALLBACKS","CONFIGURE","development","elementIds","classSelectors","enableKeepHtml","enableKeepStyles","enableSearchString","enableHashString","START_HTML","documentElement","outerHTML","SERIES_CALLBACKS","PARALLEL_CALLBACKS","RENDERED_STYLES","RENDERED_SCRIPTS","LOADED","CURRENT_PATH","Page","_createClass","_classCallCheck","this","_defineProperty","State","createElement","tagName","html","fragment","createDocumentFragment","appendChild","fragmentHtml","innerHTML","callback","enter","route","requestUrl","getStyles","styleEntries","entries","styleUrls","urls","getScripts","body","scriptUrls","end","length","current","_styleEntries$current","_slicedToArray","node","url","scriptEntries","_scriptEntries$curren","load","page","PAGES","getHref","title","styles","unload","anchor","links","getAttribute","startsWith","setAttribute","store","callbacks","exitCallbacks","concat","reason","console","warn","abort","render","pushState","request","_ref2","_ref","then","_ref3","_ref4","responseUrl","rawHtml","innerText","classMap","selector","getElementsByTagName","className","_getScripts2","parentNode","removeChild","querySelector","targetHTML","target","join","scripts","URL","pathname","endsWith","parse","apply","arguments","AbortController","fetch","signal","responseText","response","Promise","all","resolve","text","history","hash","search","substring","scrollTo","classes","indexOf","changeAll","replaceMap","to","getElementById","replaceChild","_document$body","append","_toConsumableArray","children","catchError","_document$head","addStyle","elements","importPromises","renderedStyleHrefs","Object","keys","removeStyles","link","promise","_addStyle","script","src","_RENDERED_SCRIPTS$src","_addScript","addScript","head","onLoad","getResources","parentElement","attributeName","nodes","querySelectorAll","value","series","_loop","prepares","catchReload","style","changedElement","splice","enterCallbacks","byId","reload","configure","assign","parallel","tag","resolver","onload","async","ready","onerror","exit","replace","changed","addEventListener","event","_singularAnchor","closest","rawHref","download","stopPropagation","preventDefault","_node$dataset","dataset","outlet","inlineOutlet","split","state","visibility"],"mappings":"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","file":"singular.js","sourcesContent":["\"use strict\";\n/**\n * @alias singular.enter\n * @returns singular\n */\nconst singular = (function (window, document, undefined) {\n    const { href: START_PATH, origin: ORIGIN } = location;\n    const { from: FROM } = Array;\n    const READY_CALLBACKS = [];\n    const LOAD_CALLBACKS = [];\n    const UNLOAD_CALLBACKS = [];\n    let CONFIGURE = {\n        development: false,\n        elementIds: null,\n        classSelectors: null,\n        enableKeepHtml: false,\n        enableKeepStyles: false,\n        enableSearchString: false,\n        enableHashString: false\n    };\n    let START_HTML = document.documentElement.outerHTML;\n    let SERIES_CALLBACKS = [];\n    let PARALLEL_CALLBACKS = [];\n    let RENDERED_STYLES = {};\n    let RENDERED_SCRIPTS = {};\n    let LOADED = false;\n    let CURRENT_PATH = START_PATH;\n    let ABORTER;\n    class Page {\n        url;\n        title;\n        styles;\n        scripts;\n        enterCallbacks = [];\n        exitCallbacks = [];\n        classes;\n        html;\n    }\n    class State {\n        singular;\n        constructor(href) {\n            this.singular = {\n                href\n            };\n        }\n    }\n    const PAGES = {\n        [START_PATH]: new Page\n    };\n    function tag(tagName) {\n        return document.createElement(tagName);\n    }\n    function byId(id) {\n        return document.getElementById(id);\n    }\n    function fragmentHtml(html) {\n        const fragment = document.createDocumentFragment();\n        const fragmentHtml = tag('html');\n        fragment.appendChild(fragmentHtml);\n        fragmentHtml.innerHTML = html;\n        return fragmentHtml;\n    }\n    /**\n     * @alias singular.enter\n     * @param callback\n     */\n    function singular(callback) {\n        return singular.enter(callback);\n    }\n    /**\n     * Set Configure\n     * @param configure\n     */\n    singular.configure = function (configure) {\n        const { elementIds, classSelectors } = configure;\n        if (elementIds) {\n            if (typeof elementIds === 'string') {\n                configure.elementIds = [elementIds];\n            }\n            if (elementIds.indexOf('body') > -1) {\n                configure.elementIds = null;\n            }\n        }\n        if (classSelectors) {\n            if (typeof classSelectors === 'string') {\n                configure.classSelectors = [classSelectors];\n            }\n        }\n        CONFIGURE = Object.assign(CONFIGURE, configure);\n        return singular;\n    };\n    /**\n     * Set Series Callback for Bootstrap\n     * @description\n     *   Callbacks Call as Single Thread\n     *   If Previous Callback to failed, Does not Move to Next Callback.\n     * @param callback\n     */\n    singular.series = function (callback) {\n        SERIES_CALLBACKS[SERIES_CALLBACKS.length] = callback;\n        return singular;\n    };\n    /**\n     * Set Parallel Callback for Bootstrap\n     * @description\n     *   Callbacks Call as Multiple Thread\n     * @param callback\n     */\n    singular.parallel = function (callback) {\n        PARALLEL_CALLBACKS[PARALLEL_CALLBACKS.length] = callback;\n        return singular;\n    };\n    /**\n     * Add External Stylesheet to <HEAD> Using <LINK>\n     * @param href\n     */\n    singular.addStyle = function (href) {\n        const link = tag('link');\n        return {\n            link,\n            promise: new Promise((resolve) => {\n                const resolver = () => resolve();\n                link.onload = resolver;\n                link.onerror = resolver;\n                link.rel = 'stylesheet';\n                document.head.append(link);\n                link.href = href;\n            })\n        };\n    };\n    /**\n     *  Add External Stylesheet to <HEAD> Using <SCRIPT>\n     * @param src\n     * @param async\n     */\n    singular.addScript = function (src, async = true) {\n        const script = tag('script');\n        return {\n            script,\n            promise: new Promise((resolve) => {\n                const resolver = () => resolve();\n                script.onload = resolver;\n                script.onerror = resolver;\n                script.async = async;\n                document.head.append(script);\n                script.src = src;\n            })\n        };\n    };\n    /**\n     * Run Once in Declared Document after DOMContentLoaded\n     * @param callback\n     */\n    singular.ready = function (callback) {\n        READY_CALLBACKS[READY_CALLBACKS.length] = callback;\n        if (LOADED) {\n            callback(document.body);\n        }\n        return singular;\n    };\n    /**\n     * Run Everytime in Every Document after DOMContentLoaded\n     * @param callback\n     */\n    singular.load = function (callback) {\n        LOAD_CALLBACKS[LOAD_CALLBACKS.length] = callback;\n        if (LOADED) {\n            callback(document.body);\n        }\n        return singular;\n    };\n    singular.unload = function (callback) {\n        UNLOAD_CALLBACKS[UNLOAD_CALLBACKS.length] = callback;\n        return singular;\n    };\n    /**\n     * Run Everytime in Declared Document after DOMContentLoaded\n     * @alias singular\n     * @param callback\n     */\n    singular.enter = function (callback) {\n        const store = PAGES[CURRENT_PATH].enterCallbacks;\n        store[store.length] = callback;\n        if (LOADED) {\n            callback(document.body);\n        }\n        return singular;\n    };\n    /**\n     * Run Everytime in Declared Document after beforeunload\n     * @param callback\n     */\n    singular.exit = function (callback) {\n        const { exitCallbacks } = PAGES[CURRENT_PATH];\n        exitCallbacks[exitCallbacks.length] = callback;\n        return singular;\n    };\n    /**\n     * Move to Other Document\n     * @param requestUrl\n     * @param elementIds\n     */\n    singular.route = function (requestUrl, elementIds) {\n        try {\n            route(requestUrl, elementIds);\n        }\n        catch (reason) {\n            console.warn(reason);\n            if (!CONFIGURE.development) {\n                location.replace(requestUrl);\n            }\n            return null;\n        }\n    };\n    /**\n     * Signal for DOM Changed by any codes\n     * @param target\n     */\n    singular.changed = function (target = document.body) {\n        const end = LOAD_CALLBACKS.length;\n        let current = -1;\n        while (++current < end) {\n            LOAD_CALLBACKS[current](target);\n        }\n        return singular;\n    };\n    function route(requestUrl, elementIds) {\n        const { entries: styleEntries, urls: styleUrls } = getStyles(document.documentElement);\n        const { entries: scriptEntries, urls: scriptUrls } = getScripts(document.documentElement);\n        let end = styleEntries.length;\n        let current = -1;\n        while (++current > end) {\n            const [node, url] = styleEntries[current];\n            RENDERED_STYLES[url] = node;\n        }\n        end = scriptEntries.length;\n        current = -1;\n        while (++current < end) {\n            const [node, url] = scriptEntries[current];\n            RENDERED_SCRIPTS[url] = node;\n            document.head.append(node);\n        }\n        const page = PAGES[getHref(START_PATH)];\n        page.url = START_PATH;\n        page.title = document.title;\n        page.styles = styleUrls;\n        page.scripts = scriptUrls;\n        page.html = START_HTML;\n        START_HTML = null;\n        const { links } = document;\n        current = links.length;\n        while (current-- > 0) {\n            const anchor = links[current];\n            const href = anchor.getAttribute('href');\n            if (!href || !(href.startsWith('./') || href.startsWith('../'))) {\n                continue;\n            }\n            anchor.setAttribute('href', anchor.href);\n        }\n        // @ts-ignore\n        return (route = function (requestUrl, elementIds) {\n            // console.debug(`[singular] ${href}`);\n            if (LOADED) {\n                const callbacks = PAGES[CURRENT_PATH].exitCallbacks.concat(UNLOAD_CALLBACKS);\n                const end = callbacks.length;\n                let current = -1;\n                try {\n                    while (++current < end) {\n                        callbacks[current]();\n                    }\n                }\n                catch (reason) {\n                    console.warn(reason);\n                }\n            }\n            else if (ABORTER) {\n                ABORTER.abort();\n            }\n            window.scrollTo(0, 0);\n            // document.title = requestUrl.substring(requestUrl.indexOf(':') + 3);\n            LOADED = false;\n            CURRENT_PATH = getHref(requestUrl);\n            const page = PAGES[CURRENT_PATH];\n            if (page) {\n                if (CONFIGURE.enableKeepHtml) {\n                    render(page);\n                    pushState(page.url);\n                }\n                else {\n                    request(requestUrl)\n                        .then(([responseUrl, html]) => {\n                        page.html = html;\n                        render(page);\n                    });\n                }\n            }\n            else {\n                request(requestUrl)\n                    .then(([responseUrl, html]) => {\n                    parse(requestUrl, responseUrl, html, elementIds || CONFIGURE.elementIds);\n                });\n            }\n        }).apply(this, arguments);\n        function request(href) {\n            ABORTER = new AbortController();\n            return fetch(href, {\n                signal: ABORTER.signal\n            })\n                .then(responseText)\n                .catch(catchError);\n        }\n        function responseText(response) {\n            const { url } = response;\n            pushState(url);\n            return Promise.all([\n                Promise.resolve(url),\n                response.text()\n            ]);\n        }\n        function catchError(reason) {\n            console.warn(reason);\n        }\n        function pushState(url) {\n            history.pushState(new State(url), url, url);\n        }\n    }\n    function parse(requestUrl, responseUrl, rawHtml, elementIds) {\n        const fragment = fragmentHtml(rawHtml);\n        const title = (fragment.getElementsByTagName('TITLE')[0] || {}).innerText || requestUrl;\n        const { classSelectors } = CONFIGURE;\n        let current;\n        let classMap = null;\n        if (classSelectors) {\n            classMap = {};\n            current = classSelectors.length;\n            while (current-- > 0) {\n                const selector = classSelectors[current];\n                classMap[selector] = (fragment.getElementsByTagName(selector)[0] || {}).className || '';\n            }\n        }\n        const { urls: styleUrls } = getStyles(fragment);\n        const { entries: scriptEntries, urls: scriptUrls } = getScripts(fragment);\n        current = scriptEntries.length;\n        while (current-- > 0) {\n            const [node] = scriptEntries[current];\n            if (node?.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        }\n        let html;\n        if (elementIds) {\n            const targetHTML = [];\n            let current = elementIds.length;\n            while (current-- > 0) {\n                const target = fragment.querySelector('#' + elementIds[current]);\n                if (target) {\n                    targetHTML[targetHTML.length] = target.outerHTML;\n                }\n            }\n            html = targetHTML.join('');\n        }\n        else {\n            html = fragment.outerHTML;\n        }\n        const page = new Page;\n        page.url = responseUrl;\n        page.title = title;\n        page.styles = styleUrls;\n        page.scripts = scriptUrls;\n        page.classes = classMap;\n        page.html = html;\n        const url = new URL(CURRENT_PATH);\n        if (url.pathname.endsWith('/')) {\n            url.pathname = url.pathname.substring(0, url.pathname.length - 1);\n        }\n        PAGES['' + url] = page;\n        render(page);\n    }\n    function getHref(href) {\n        const url = new URL(href);\n        if (!CONFIGURE.enableHashString) {\n            url.hash = '';\n        }\n        if (!CONFIGURE.enableSearchString) {\n            url.search = '';\n        }\n        let { pathname } = url;\n        if (pathname.endsWith('/')) {\n            url.pathname = pathname.substring(0, pathname.length - 1);\n        }\n        return '' + url;\n    }\n    function render(page) {\n        const { url, title, styles, scripts, classes, html } = page;\n        const { elementIds, classSelectors } = CONFIGURE;\n        document.title = title || url.substring(url.indexOf('://') + 3);\n        if (classSelectors && classes) {\n            let current = classSelectors.length;\n            while (current-- > 0) {\n                const selector = classSelectors[current];\n                const target = document.documentElement.querySelector(selector);\n                if (target) {\n                    target.className = classes[selector];\n                }\n            }\n        }\n        const fragment = fragmentHtml(html);\n        let changeAll = false;\n        if (elementIds) {\n            const replaceMap = [];\n            let current = elementIds.length;\n            while (current-- > 0) {\n                const selector = elementIds[current];\n                const from = fragment.querySelector('#' + selector);\n                const to = byId(selector);\n                if (!from || !to) {\n                    changeAll = true;\n                    break;\n                }\n                replaceMap[replaceMap.length] = [from, to];\n            }\n            if (!changeAll) {\n                current = replaceMap.length;\n                while (current-- > 0) {\n                    const [from, to] = replaceMap[current];\n                    to.parentNode.replaceChild(from, to);\n                }\n            }\n        }\n        else {\n            changeAll = true;\n        }\n        if (changeAll) {\n            document.body.innerHTML = '';\n            document.body.append(...(fragment.getElementsByTagName('BODY')[0] || fragment).children);\n        }\n        fragment.innerHTML = '';\n        const { addScript, addStyle } = singular;\n        const elements = [];\n        const importPromises = [Promise.resolve()];\n        const removeStyles = [];\n        let end;\n        let current;\n        if (!CONFIGURE.enableKeepStyles) {\n            const renderedStyleHrefs = Object.keys(RENDERED_STYLES);\n            current = renderedStyleHrefs.length;\n            while (current-- > 0) {\n                let href = renderedStyleHrefs[current];\n                if (styles.indexOf(href) > -1) {\n                    continue;\n                }\n                // RENDERED_STYLES[href].disabled = true;\n                removeStyles[removeStyles.length] = RENDERED_STYLES[href];\n                delete RENDERED_STYLES[href];\n            }\n        }\n        // add external stylesheet\n        end = styles.length;\n        current = -1;\n        while (++current < end) {\n            const href = styles[current];\n            if (RENDERED_STYLES[href]) {\n                //     RENDERED_STYLES[href].disabled = false;\n                continue;\n            }\n            const { link, promise } = addStyle(href);\n            RENDERED_STYLES[href] = link;\n            importPromises[importPromises.length] = promise;\n            elements[elements.length] = link;\n        }\n        // add external script\n        end = scripts.length;\n        current = -1;\n        while (++current < end) {\n            const src = scripts[current];\n            if (RENDERED_SCRIPTS[src]?.parentNode) {\n                // console.log(RENDERED_SCRIPTS[src], RENDERED_SCRIPTS[src].parentNode);\n                continue;\n            }\n            const { script, promise } = addScript(src);\n            RENDERED_SCRIPTS[src] = script;\n            importPromises[importPromises.length] = promise;\n            elements[elements.length] = script;\n        }\n        if (elements.length) {\n            document.head.append(...elements);\n        }\n        Promise.all(importPromises)\n            .then(() => {\n            let current = removeStyles.length;\n            while (current-- > 0) {\n                const link = removeStyles[current];\n                if (link && link.parentNode) {\n                    link.parentNode.removeChild(link);\n                }\n            }\n            onLoad();\n        });\n    }\n    function getResources(parentElement, selector, attributeName) {\n        const entries = [];\n        const urls = [];\n        const nodes = FROM(parentElement.querySelectorAll(selector));\n        const end = nodes.length;\n        let current = -1;\n        while (++current < end) {\n            const node = nodes[current];\n            if (!node.getAttribute(attributeName) || node[attributeName].startsWith(ORIGIN)) {\n                continue;\n            }\n            const value = getFixedUrl(node, attributeName);\n            entries[entries.length] = [node, value];\n            urls[urls.length] = value;\n        }\n        return { entries, urls };\n    }\n    function getStyles(parentElement) {\n        return getResources(parentElement, 'link[rel=stylesheet]', 'href');\n    }\n    function getScripts(parentElement) {\n        return getResources(parentElement, 'script[src]', 'src');\n    }\n    function getFixedUrl(node, attribute) {\n        return '' + (new URL(node.getAttribute(attribute), location.href));\n    }\n    function onLoad() {\n        // console.debug('[singular] before load');\n        const end = SERIES_CALLBACKS.length;\n        let current = -1;\n        let series = Promise.resolve();\n        while (++current < end) {\n            const callback = SERIES_CALLBACKS[current];\n            series = series.then(() => callback());\n        }\n        const prepares = [series];\n        current = PARALLEL_CALLBACKS.length;\n        while (current-- > 0) {\n            prepares[prepares.length] = PARALLEL_CALLBACKS[current]();\n        }\n        SERIES_CALLBACKS = [];\n        PARALLEL_CALLBACKS = [];\n        Promise.all(prepares)\n            .then(onLoading)\n            .catch(catchReload);\n    }\n    function onLoading() {\n        // console.debug('[singular] after load');\n        document.documentElement.style.visibility = 'inherit';\n        try {\n            onLoaded();\n        }\n        catch (reason) {\n            console.warn(reason);\n        }\n    }\n    function catchReload(reason) {\n        console.warn(reason);\n        if (!CONFIGURE.development) {\n            location.reload();\n        }\n    }\n    function onLoaded(changedElement = document.body) {\n        // console.debug('[singular] Loaded');\n        LOADED = true;\n        const page = PAGES[CURRENT_PATH];\n        const callbacks = [\n            ...READY_CALLBACKS.splice(0, READY_CALLBACKS.length),\n            ...LOAD_CALLBACKS,\n            ...page.enterCallbacks\n        ];\n        const end = callbacks.length;\n        let current = -1;\n        while (++current < end) {\n            callbacks[current](changedElement);\n        }\n    }\n    addEventListener('click', function onClick(event) {\n        let node = event.target;\n        switch (node.tagName) {\n            case 'BODY':\n                return false;\n            case 'A':\n                break;\n            default:\n                if (node._singularAnchor === false) {\n                    return true;\n                }\n                const anchor = node.closest('a');\n                if (!anchor || !anchor.href) {\n                    node._singularAnchor = false;\n                    return true;\n                }\n                node = anchor;\n        }\n        const { href } = node;\n        const rawHref = node.getAttribute('href');\n        if (!href.startsWith(ORIGIN)\n            || node.download\n            || (rawHref && rawHref.startsWith('#'))) {\n            node._singularAnchor = false;\n            return true;\n        }\n        node._singularAnchor = node;\n        event.stopPropagation();\n        event.preventDefault();\n        const inlineOutlet = node.dataset?.outlet;\n        singular.route(href, inlineOutlet ? inlineOutlet.split(',') : undefined);\n        return false;\n    });\n    addEventListener('popstate', function onPopstate(event) {\n        const { state } = event;\n        if (state && state.singular) {\n            route(state.singular.href);\n        }\n        return true;\n    });\n    addEventListener('DOMContentLoaded', function onDOMContentLoaded() {\n        CURRENT_PATH = getHref(START_PATH);\n        if (START_PATH !== CURRENT_PATH) {\n            PAGES[CURRENT_PATH] = PAGES[START_PATH];\n            delete PAGES[START_PATH];\n        }\n        document.documentElement.style.visibility = 'hidden';\n        onLoad();\n    });\n    return singular;\n})(window, document);\n"]}