{"version":3,"names":[],"mappings":"","sources":["singular.js"],"sourcesContent":["\"use strict\";\nconst singular = (function singularInit(window, document, undefined) {\n    const { href: START_URL, origin: ORIGIN } = location;\n    const { from: FROM } = Array;\n    let CONFIGURE = {\n        development: false,\n        outletSelectors: null,\n        classSelectors: null,\n        enableKeepHtml: false,\n        enableKeepStyles: false,\n        enableSearchString: false,\n        enableHashString: false,\n        disableTitleChange: false\n    };\n    let RENDERED_STYLES = {};\n    let RENDERED_SCRIPTS = {};\n    let LOADED = false;\n    let CURRENT_URL = START_URL;\n    let CURRENT_SCRIPT_URL = START_URL;\n    let ABORTER;\n    class Page {\n        url;\n        title;\n        styles;\n        scripts;\n        classes;\n        html;\n    }\n    class Lifecycle {\n        static seriesCallbacks = [];\n        static parallelCallbacks = [];\n        static readyCallbacks = [];\n        static loadCallbacks = [];\n        static unloadCallbacks = [];\n        enterCallbacks = [];\n        exitCallbacks = [];\n    }\n    class State {\n        singular;\n        constructor(href) {\n            this.singular = {\n                href\n            };\n        }\n    }\n    const PAGES = {\n        [START_URL]: new Page\n    };\n    const LIFECYCLES = {\n        [START_URL]: new Lifecycle\n    };\n    addEventListener('click', function singularOnClick(event) {\n        let node = event.target;\n        switch (node.tagName) {\n            case 'BODY':\n                return false;\n            case 'A':\n                break;\n            default:\n                if (node._singularAnchor === false) {\n                    return true;\n                }\n                const anchor = node.closest('a');\n                if (!anchor || !anchor.href) {\n                    node._singularAnchor = false;\n                    return true;\n                }\n                node = anchor;\n        }\n        const { href } = node;\n        const rawHref = node.getAttribute('href');\n        if (node.target\n            || node.download\n            || !href.startsWith(ORIGIN)\n            || (rawHref && rawHref.startsWith('#'))) {\n            node._singularAnchor = false;\n            return true;\n        }\n        node._singularAnchor = node;\n        event.stopPropagation();\n        event.preventDefault();\n        const inlineOutlet = node.dataset?.outlet;\n        singular.route(href, inlineOutlet ? inlineOutlet.split(',') : undefined);\n        return false;\n    });\n    addEventListener('popstate', function singularOnPopstate(event) {\n        const { state } = event;\n        if (state && state.singular) {\n            route(state.singular.href, undefined, false);\n        }\n        return true;\n    });\n    addEventListener('DOMContentLoaded', function singularOnDOMContentLoaded() {\n        PAGES[CURRENT_URL].html = document.documentElement.outerHTML;\n        CURRENT_URL = getHref(START_URL);\n        CURRENT_SCRIPT_URL = getScriptUrl(START_URL);\n        if (START_URL !== CURRENT_URL) {\n            PAGES[CURRENT_URL] = PAGES[START_URL];\n            delete PAGES[START_URL];\n        }\n        if (START_URL !== CURRENT_SCRIPT_URL) {\n            LIFECYCLES[CURRENT_SCRIPT_URL] = LIFECYCLES[START_URL];\n            delete LIFECYCLES[START_URL];\n        }\n        document.documentElement.style.visibility = 'hidden';\n        onLoad();\n    });\n    return class Singular {\n        /**\n         * Set Configure\n         * @param configure\n         */\n        static configure(configure) {\n            const { outletSelectors, classSelectors } = configure;\n            if (outletSelectors) {\n                if (typeof outletSelectors === 'string') {\n                    configure.outletSelectors = [outletSelectors];\n                }\n                if (outletSelectors.indexOf('body') > -1) {\n                    configure.outletSelectors = ['body'];\n                }\n            }\n            if (classSelectors) {\n                if (typeof classSelectors === 'string') {\n                    configure.classSelectors = [classSelectors];\n                }\n            }\n            CONFIGURE = Object.assign(CONFIGURE, configure);\n            return this;\n        }\n        /**\n         * Add External Stylesheet to <HEAD> Using <LINK>\n         * @param href\n         */\n        static addStyle(href) {\n            const link = tag('link');\n            return {\n                link,\n                promise: new Promise((resolve) => {\n                    const resolver = () => resolve();\n                    link.onload = resolver;\n                    link.onerror = resolver;\n                    link.rel = 'stylesheet';\n                    document.head.append(link);\n                    link.href = href;\n                })\n            };\n        }\n        ;\n        /**\n         *  Add External Stylesheet to <HEAD> Using <SCRIPT>\n         * @param src\n         * @param async\n         */\n        static addScript(src, async = true) {\n            const script = tag('script');\n            return {\n                script,\n                promise: new Promise((resolve) => {\n                    const resolver = () => resolve();\n                    script.onload = resolver;\n                    script.onerror = resolver;\n                    script.async = async;\n                    document.head.append(script);\n                    script.src = src;\n                })\n            };\n        }\n        ;\n        /**\n         * Set Parallel Callback for Bootstrap\n         * @description\n         *   Callbacks Call as Multiple Thread\n         * @param callback\n         */\n        static parallel(callback) {\n            Lifecycle.parallelCallbacks[Lifecycle.parallelCallbacks.length] = callback;\n            return this;\n        }\n        /**\n         * Set Series Callback for Bootstrap\n         * @description\n         *   Callbacks Call as Single Thread\n         *   If Previous Callback to failed, Does not Move to Next Callback.\n         * @param callback\n         */\n        static series(callback) {\n            Lifecycle.seriesCallbacks[Lifecycle.seriesCallbacks.length] = callback;\n            return this;\n        }\n        /**\n         * Run Once in Declared Document after DOMContentLoaded\n         * @param callback\n         */\n        static ready(callback) {\n            Lifecycle.readyCallbacks[Lifecycle.readyCallbacks.length] = callback;\n            if (LOADED) {\n                callback(document.body);\n            }\n            return this;\n        }\n        /**\n         * Run Everytime in Every Document after DOMContentLoaded\n         * @param callback\n         */\n        static load(callback) {\n            Lifecycle.loadCallbacks[Lifecycle.loadCallbacks.length] = callback;\n            if (LOADED) {\n                callback(document.body);\n            }\n            return this;\n        }\n        /**\n         * Run Everytime in Declared Document after DOMContentLoaded\n         * @alias singular\n         * @param callback\n         */\n        static enter(callback) {\n            const { enterCallbacks } = LIFECYCLES[CURRENT_SCRIPT_URL];\n            enterCallbacks[enterCallbacks.length] = callback;\n            if (LOADED) {\n                callback(document.body);\n            }\n            return this;\n        }\n        /**\n         * Run Everytime in Declared Document after beforeunload\n         * @param callback\n         */\n        static exit(callback) {\n            const { exitCallbacks } = LIFECYCLES[CURRENT_SCRIPT_URL];\n            exitCallbacks[exitCallbacks.length] = callback;\n            return this;\n        }\n        ;\n        static unload(callback) {\n            Lifecycle.unloadCallbacks[Lifecycle.unloadCallbacks.length] = callback;\n            return this;\n        }\n        /**\n         * Move to Other Document\n         * @param requestUrl\n         * @param outletSelectors\n         */\n        static route(requestUrl, outletSelectors) {\n            try {\n                route(requestUrl, outletSelectors);\n            }\n            catch (reason) {\n                console.warn(reason);\n                if (!CONFIGURE.development) {\n                    location.replace(requestUrl);\n                }\n                return null;\n            }\n        }\n        /**\n         * Signal for DOM Changed by any codes\n         * @param target\n         */\n        static changed(target = document.body) {\n            const end = Lifecycle.loadCallbacks.length;\n            let current = -1;\n            while (++current < end) {\n                Lifecycle.loadCallbacks[current](target);\n            }\n            return this;\n        }\n    };\n    function tag(tagName) {\n        return document.createElement(tagName);\n    }\n    function byId(id) {\n        return document.getElementById(id);\n    }\n    function fragmentHtml(html) {\n        const fragment = document.createDocumentFragment();\n        const fragmentHtml = tag('html');\n        fragment.appendChild(fragmentHtml);\n        fragmentHtml.innerHTML = html;\n        return fragmentHtml;\n    }\n    function route(requestUrl, outletSelectors = undefined, push = true) {\n        const { entries: styleEntries, urls: styleUrls } = getStyles(document.documentElement);\n        const { entries: scriptEntries, urls: scriptUrls } = getScripts(document.documentElement);\n        let end = styleEntries.length;\n        let current = -1;\n        while (++current > end) {\n            const [node, url] = styleEntries[current];\n            RENDERED_STYLES[url] = node;\n        }\n        end = scriptEntries.length;\n        current = -1;\n        while (++current < end) {\n            const [node, url] = scriptEntries[current];\n            RENDERED_SCRIPTS[url] = node;\n            document.head.append(node);\n        }\n        const page = PAGES[CURRENT_URL];\n        page.url = START_URL;\n        page.title = document.title;\n        page.styles = styleUrls;\n        page.scripts = scriptUrls;\n        const { links } = document;\n        current = links.length;\n        while (current-- > 0) {\n            const anchor = links[current];\n            const href = anchor.getAttribute('href');\n            if (!href || !(href.startsWith('./') || href.startsWith('../'))) {\n                continue;\n            }\n            anchor.setAttribute('href', anchor.href);\n        }\n        // @ts-ignore\n        return (route = routeAfterFirstRouted).apply(this, arguments);\n        function routeAfterFirstRouted(requestUrl, outletSelectors = undefined, push = true) {\n            // console.debug(`[singular] ${href}`);\n            if (LOADED) {\n                const lifecycle = LIFECYCLES[CURRENT_SCRIPT_URL];\n                const callbacks = lifecycle.exitCallbacks.concat(Lifecycle.unloadCallbacks);\n                const end = callbacks.length;\n                let current = -1;\n                try {\n                    while (++current < end) {\n                        callbacks[current]();\n                    }\n                }\n                catch (reason) {\n                    console.warn(reason);\n                }\n            }\n            else if (ABORTER) {\n                ABORTER.abort();\n            }\n            window.scrollTo(0, 0);\n            // document.title = requestUrl.substring(requestUrl.indexOf(':') + 3);\n            LOADED = false;\n            CURRENT_URL = getHref(requestUrl);\n            CURRENT_SCRIPT_URL = getScriptUrl(requestUrl);\n            const page = PAGES[CURRENT_URL];\n            if (page) {\n                if (CONFIGURE.enableKeepHtml) {\n                    push && pushState(getFixedUrl(page.url, requestUrl));\n                    render(page);\n                }\n                // noinspection JSUnusedLocalSymbols\n                return request(requestUrl)\n                    .then(([responseUrl, html]) => {\n                    page.html = html;\n                    push && pushState(responseUrl);\n                    render(page);\n                });\n            }\n            return request(requestUrl)\n                .then(([responseUrl, html]) => {\n                push && pushState(responseUrl);\n                parse(requestUrl, responseUrl, html, outletSelectors || CONFIGURE.outletSelectors);\n            });\n        }\n        function request(href) {\n            ABORTER = new AbortController();\n            return fetch(href, {\n                signal: ABORTER.signal\n            })\n                .then(responseText)\n                .catch(catchError);\n        }\n        function responseText(response) {\n            const { url } = response;\n            return Promise.all([\n                Promise.resolve(url),\n                response.text()\n            ]);\n        }\n        function catchError(reason) {\n            console.warn(reason);\n        }\n        function pushState(responseUrl) {\n            history.pushState(new State(responseUrl), responseUrl, responseUrl);\n        }\n        function getFixedUrl(responseUrl, requestUrl) {\n            const parsedResponseUrl = new URL(responseUrl);\n            const parsedRequestUrl = new URL(requestUrl);\n            parsedResponseUrl.search = parsedRequestUrl.search;\n            parsedResponseUrl.hash = parsedRequestUrl.hash;\n            return '' + parsedRequestUrl;\n        }\n    }\n    function parse(requestUrl, responseUrl, rawHtml, elementIds) {\n        const fragment = fragmentHtml(rawHtml);\n        const title = (fragment.getElementsByTagName('TITLE')[0] || {}).innerText || requestUrl;\n        const { classSelectors } = CONFIGURE;\n        let current;\n        let classMap = null;\n        if (classSelectors) {\n            classMap = {};\n            current = classSelectors.length;\n            while (current-- > 0) {\n                const selector = classSelectors[current];\n                classMap[selector] = (fragment.getElementsByTagName(selector)[0] || {}).className || '';\n            }\n        }\n        const { urls: styleUrls } = getStyles(fragment);\n        const { entries: scriptEntries, urls: scriptUrls } = getScripts(fragment);\n        current = scriptEntries.length;\n        while (current-- > 0) {\n            const [node] = scriptEntries[current];\n            if (node?.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        }\n        let html;\n        if (elementIds) {\n            const targetHTML = [];\n            let current = elementIds.length;\n            while (current-- > 0) {\n                const target = fragment.querySelector('#' + elementIds[current]);\n                if (target) {\n                    targetHTML[targetHTML.length] = target.outerHTML;\n                }\n            }\n            html = targetHTML.join('');\n        }\n        else {\n            html = fragment.outerHTML;\n        }\n        const page = new Page;\n        page.url = responseUrl;\n        page.title = title;\n        page.styles = styleUrls;\n        page.scripts = scriptUrls;\n        page.classes = classMap;\n        page.html = html;\n        const url = new URL(CURRENT_URL);\n        if (url.pathname.endsWith('/')) {\n            url.pathname = url.pathname.substring(0, url.pathname.length - 1);\n        }\n        PAGES['' + url] = page;\n        const scriptUrl = getScriptUrl('' + url);\n        if (!LIFECYCLES[scriptUrl]) {\n            LIFECYCLES[scriptUrl] = new Lifecycle();\n        }\n        render(page);\n    }\n    function getHref(href) {\n        const url = new URL(href);\n        if (!CONFIGURE.enableHashString) {\n            url.hash = '';\n        }\n        if (!CONFIGURE.enableSearchString) {\n            url.search = '';\n        }\n        let { pathname } = url;\n        if (pathname.endsWith('/')) {\n            url.pathname = pathname.substring(0, pathname.length - 1);\n        }\n        return '' + url;\n    }\n    function getScriptUrl(href) {\n        const url = new URL(href);\n        url.hash = '';\n        url.search = '';\n        let { pathname } = url;\n        if (pathname.endsWith('/')) {\n            url.pathname = pathname.substring(0, pathname.length - 1);\n        }\n        return '' + url;\n    }\n    function render(page) {\n        const { url, title, styles, scripts, classes, html } = page;\n        const { outletSelectors, classSelectors } = CONFIGURE;\n        if (!CONFIGURE.disableTitleChange) {\n            document.title = title || url.substring(url.indexOf('://') + 3);\n        }\n        if (classSelectors && classes) {\n            let current = classSelectors.length;\n            while (current-- > 0) {\n                const selector = classSelectors[current];\n                const target = document.documentElement.querySelector(selector);\n                if (target) {\n                    target.className = classes[selector];\n                }\n            }\n        }\n        const fragment = fragmentHtml(html);\n        let changeAll = false;\n        if (outletSelectors) {\n            const replaceMap = [];\n            let current = outletSelectors.length;\n            while (current-- > 0) {\n                const selector = outletSelectors[current];\n                const from = fragment.querySelector(selector);\n                const to = document.querySelector(selector);\n                if (!from || !to) {\n                    changeAll = true;\n                    break;\n                }\n                replaceMap[replaceMap.length] = [from, to];\n            }\n            if (!changeAll) {\n                current = replaceMap.length;\n                while (current-- > 0) {\n                    const [from, to] = replaceMap[current];\n                    to.parentNode.replaceChild(from, to);\n                }\n            }\n        }\n        else {\n            changeAll = true;\n        }\n        if (changeAll) {\n            document.body.innerHTML = (fragment.getElementsByTagName('BODY')[0] || fragment).innerHTML;\n            document.body.append(...(fragment.getElementsByTagName('BODY')[0] || fragment).children);\n        }\n        fragment.innerHTML = '';\n        const { addScript, addStyle } = singular;\n        const elements = [];\n        const importPromises = [Promise.resolve()];\n        const removeStyles = [];\n        let end;\n        let current;\n        if (!CONFIGURE.enableKeepStyles) {\n            const renderedStyleHrefs = Object.keys(RENDERED_STYLES);\n            current = renderedStyleHrefs.length;\n            while (current-- > 0) {\n                let href = renderedStyleHrefs[current];\n                if (styles.indexOf(href) > -1) {\n                    continue;\n                }\n                // RENDERED_STYLES[href].disabled = true;\n                removeStyles[removeStyles.length] = RENDERED_STYLES[href];\n                delete RENDERED_STYLES[href];\n            }\n        }\n        // add external stylesheet\n        end = styles.length;\n        current = -1;\n        while (++current < end) {\n            const href = styles[current];\n            if (RENDERED_STYLES[href]) {\n                //     RENDERED_STYLES[href].disabled = false;\n                continue;\n            }\n            const { link, promise } = addStyle(href);\n            RENDERED_STYLES[href] = link;\n            importPromises[importPromises.length] = promise;\n            elements[elements.length] = link;\n        }\n        // add external script\n        end = scripts.length;\n        current = -1;\n        while (++current < end) {\n            const src = scripts[current];\n            if (RENDERED_SCRIPTS[src]?.parentNode) {\n                // console.log(RENDERED_SCRIPTS[src], RENDERED_SCRIPTS[src].parentNode);\n                continue;\n            }\n            const { script, promise } = addScript(src);\n            RENDERED_SCRIPTS[src] = script;\n            importPromises[importPromises.length] = promise;\n            elements[elements.length] = script;\n        }\n        if (elements.length) {\n            document.head.append(...elements);\n        }\n        Promise.all(importPromises)\n            .then(() => {\n            let current = removeStyles.length;\n            while (current-- > 0) {\n                const link = removeStyles[current];\n                if (link && link.parentNode) {\n                    link.parentNode.removeChild(link);\n                }\n            }\n            onLoad();\n        });\n    }\n    function getResources(parentElement, selector, attributeName) {\n        const entries = [];\n        const urls = [];\n        const nodes = FROM(parentElement.querySelectorAll(selector));\n        const end = nodes.length;\n        let current = -1;\n        while (++current < end) {\n            const node = nodes[current];\n            if (!node.getAttribute(attributeName) || !node[attributeName].startsWith(ORIGIN)) {\n                continue;\n            }\n            const value = getFixedUrl(node, attributeName);\n            entries[entries.length] = [node, value];\n            urls[urls.length] = value;\n        }\n        return { entries, urls };\n    }\n    function getStyles(parentElement) {\n        return getResources(parentElement, 'link[rel=stylesheet]', 'href');\n    }\n    function getScripts(parentElement) {\n        return getResources(parentElement, 'script[src]', 'src');\n    }\n    function getFixedUrl(node, attribute) {\n        return '' + (new URL(node.getAttribute(attribute), location.href));\n    }\n    function onLoad() {\n        // console.debug('[singular] before load');\n        const end = Lifecycle.seriesCallbacks.length;\n        let current = -1;\n        let series = Promise.resolve();\n        while (++current < end) {\n            const callback = Lifecycle.seriesCallbacks[current];\n            series = series.then(() => callback());\n        }\n        const prepares = [series];\n        current = Lifecycle.parallelCallbacks.length;\n        while (current-- > 0) {\n            prepares[prepares.length] = Lifecycle.parallelCallbacks[current]();\n        }\n        Lifecycle.seriesCallbacks = [];\n        Lifecycle.parallelCallbacks = [];\n        Promise.all(prepares)\n            .then(onLoading)\n            .catch(catchReload);\n    }\n    function onLoading() {\n        // console.debug('[singular] after load');\n        document.documentElement.style.visibility = 'inherit';\n        try {\n            onLoaded();\n        }\n        catch (reason) {\n            console.warn(reason);\n        }\n    }\n    function catchReload(reason) {\n        console.warn(reason);\n        if (!CONFIGURE.development) {\n            location.reload();\n        }\n    }\n    function onLoaded(changedElement = document.body) {\n        // console.debug('[singular] Loaded');\n        LOADED = true;\n        const lifecycle = LIFECYCLES[CURRENT_SCRIPT_URL];\n        const callbacks = [\n            ...Lifecycle.readyCallbacks.splice(0, Lifecycle.readyCallbacks.length),\n            ...Lifecycle.loadCallbacks,\n            ...lifecycle.enterCallbacks\n        ];\n        const end = callbacks.length;\n        let current = -1;\n        while (++current < end) {\n            callbacks[current](changedElement);\n        }\n    }\n})(window, document);\n"],"file":"singular.js"}