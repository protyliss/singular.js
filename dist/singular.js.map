{"version":3,"sources":["singular.js"],"names":["singular","window","document","undefined","fragment","HEAD","START_PATH","ORIGIN","htmlSelectors","_location","location","href","origin","FROM","Array","from","READY_CALLBACKS","LOAD_CALLBACKS","UNLOAD_CALLBACKS","CONFIGURE","development","classSelectors","enableKeepHtml","enableKeepStyles","enableSearchString","enableHashString","FRAGMENT_HTML","createDocumentFragment","fragmentHtml","createElement","appendChild","_createClass","Page","_classCallCheck","this","_defineProperty","State","START_HTML","SERIES_CALLBACKS","FETCH_CONTROLLER","callback","enter","route","LOADED","styleElements","getStyleElement","HTML","scriptElements","getScriptElement","load","current","length","BODY","getAbsoluteUrl","style","styles","unload","script","scripts","src","RENDERED_SCRIPTS","startPage","PAGES","CURRENT_PATH","title","html","store","links","anchor","getAttribute","startsWith","setAttribute","callbacks","exitCallbacks","concat","end","reason","console","warn","abort","replace","substring","indexOf","getHref","cache","pushState","request","then","render","rawHtml","innerHTML","getElementsByTagName","innerText","classMap","selector","className","page","result","getStyleHref","target","querySelector","parentNode","removeChild","scrollTo","targetHTML","outerHTML","classes","parse","apply","arguments","AbortController","fetch","signal","responseText","catchError","response","text","hashIndex","index","searchIndex","DOMException","to","children","elements","imports","Promise","resolve","removeStyles","renderedStyleHrefs","Object","keys","RENDERED_STYLES","link","promise","getScriptSrc","_addScript","addScript","append","container","querySelectorAll","node","attribute","URL","onLoad","series","parent","replaceChild","prepares","PARALLEL_CALLBACKS","all","catchReload","onLoading","_toConsumableArray","splice","changedElement","addStyle","configure","key","onload","resolver","onerror","rel","async","ready","parallel","enterCallbacks","exit","history","addEventListener","event","tagName","_singularAnchor","closest","rawHref","download","inlineOutlet","_node4$dataset","dataset","outlet","split","stopPropagation","preventDefault","state","documentElement","body","visibility"],"mappings":"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","file":"singular.js","sourcesContent":["\"use strict\";\n/**\n * Singular\n * One of Initial Series to Make Identity.\n\r\n * @author protyliss\n */\nconst singular = (function (window, document, undefined) {\n    const { href: START_PATH, origin: ORIGIN } = location;\n    const { from: FROM } = Array;\n    const READY_CALLBACKS = [];\n    const LOAD_CALLBACKS = [];\n    const UNLOAD_CALLBACKS = [];\n    const CONFIGURE = {\n        development: false,\n        htmlSelectors: null,\n        classSelectors: null,\n        enableKeepHtml: false,\n        enableKeepStyles: false,\n        enableSearchString: false,\n        enableHashString: false\n    };\n    const FRAGMENT_HTML = (() => {\n        const fragment = document.createDocumentFragment();\n        const fragmentHtml = document.createElement('html');\n        fragment.appendChild(fragmentHtml);\n        return fragmentHtml;\n    })();\n    let HTML;\n    let HEAD;\n    let BODY;\n    let START_HTML;\n    let SERIES_CALLBACKS = [];\n    let PARALLEL_CALLBACKS = [];\n    let RENDERED_STYLES = {};\n    let RENDERED_SCRIPTS = {};\n    let LOADED = false;\n    let CURRENT_PATH = START_PATH;\n    let FETCH_CONTROLLER;\n    class Page {\n        title;\n        styles;\n        scripts;\n        enterCallbacks = [];\n        exitCallbacks = [];\n        classes;\n        html;\n    }\n    class State {\n        singular;\n        constructor(href) {\n            this.singular = {\n                href\n            };\n        }\n    }\n    const PAGES = {\n        [START_PATH]: new Page\n    };\n    /**\n     * @alias singular.enter\n     * @param callback\n     */\n    function singular(callback) {\n        return singular.enter(callback);\n    }\n    /**\n     * Set Configure\n     * @param configure\n     */\n    singular.configure = function (configure) {\n        if (configure.htmlSelectors) {\n            if (typeof configure.htmlSelectors === 'string') {\n                configure.htmlSelectors = [configure.htmlSelectors];\n            }\n            if (configure.htmlSelectors.indexOf('body') > -1) {\n                configure.htmlSelectors = null;\n            }\n        }\n        if (configure.classSelectors) {\n            if (typeof configure.classSelectors === 'string') {\n                configure.classSelectors = [configure.classSelectors];\n            }\n        }\n        const keys = Object.keys(configure);\n        let current = keys.length;\n        while (current-- > 0) {\n            const key = keys[current];\n            CONFIGURE[key] = configure[key];\n        }\n        return singular;\n    };\n    /**\n     * Set Series Callback for Bootstrap\n     * @description\n     *   Callbacks Call as Single Thread\n     *   If Previous Callback to failed, Does not Move to Next Callback.\n     * @param callback\n     */\n    singular.series = function (callback) {\n        SERIES_CALLBACKS[SERIES_CALLBACKS.length] = callback;\n        return singular;\n    };\n    /**\n     * Set Parallel Callback for Bootstrap\n     * @description\n     *   Callbacks Call as Multiple Thread\n     * @param callback\n     */\n    singular.parallel = function (callback) {\n        PARALLEL_CALLBACKS[PARALLEL_CALLBACKS.length] = callback;\n        return singular;\n    };\n    /**\n     * Add External Stylesheet to <HEAD> Using <LINK>\n     * @param href\n     */\n    singular.addStyle = function (href) {\n        const link = document.createElement('link');\n        return {\n            link,\n            promise: new Promise((resolve) => {\n                const resolver = () => resolve();\n                link.onload = resolver;\n                link.onerror = resolver;\n                link.rel = 'stylesheet';\n                HEAD.append(link);\n                link.href = href;\n            })\n        };\n    };\n    /**\n     *  Add External Stylesheet to <HEAD> Using <SCRIPT>\n     * @param src\n     * @param async\n     */\n    singular.addScript = function (src, async = true) {\n        const script = document.createElement('script');\n        return {\n            script,\n            promise: new Promise((resolve) => {\n                const resolver = () => resolve();\n                script.onload = resolver;\n                script.onerror = resolver;\n                script.async = async;\n                HEAD.append(script);\n                script.src = src;\n            })\n        };\n    };\n    /**\n     * Run Once in Declared Document after DOMContentLoaded\n     * @param callback\n     */\n    singular.ready = function (callback) {\n        READY_CALLBACKS[READY_CALLBACKS.length] = callback;\n        if (LOADED) {\n            callback(BODY);\n        }\n        return singular;\n    };\n    /**\n     * Run Everytime in Every Document after DOMContentLoaded\n     * @param callback\n     */\n    singular.load = function (callback) {\n        LOAD_CALLBACKS[LOAD_CALLBACKS.length] = callback;\n        if (LOADED) {\n            callback(BODY);\n        }\n        return singular;\n    };\n    singular.unload = function (callback) {\n        UNLOAD_CALLBACKS[UNLOAD_CALLBACKS.length] = callback;\n        return singular;\n    };\n    /**\n     * Run Everytime in Declared Document after DOMContentLoaded\n     * @param callback\n     */\n    singular.enter = function (callback) {\n        const store = PAGES[CURRENT_PATH].enterCallbacks;\n        store[store.length] = callback;\n        if (LOADED) {\n            callback(BODY);\n        }\n        return singular;\n    };\n    /**\n     * Run Everytime in Declared Document after beforeunload\n     * @param callback\n     */\n    singular.exit = function (callback) {\n        const store = PAGES[CURRENT_PATH].exitCallbacks;\n        store[store.length] = callback;\n        return singular;\n    };\n    /**\n     * Move to Other Document\n     * @param href\n     * @param htmlSelectors\n     */\n    singular.route = function (href, htmlSelectors) {\n        try {\n            route(href, htmlSelectors);\n        }\n        catch (reason) {\n            console.warn(reason);\n            if (!CONFIGURE.development) {\n                location.replace(href);\n            }\n            return null;\n        }\n        history.pushState(new State(href), href, href);\n    };\n    /**\n     * Signal for DOM Changed by any codes\n     * @param target\n     */\n    singular.changed = function (target = BODY) {\n        const end = LOAD_CALLBACKS.length;\n        let current = -1;\n        while (++current < end) {\n            LOAD_CALLBACKS[current](target);\n        }\n        return singular;\n    };\n    function route(href, htmlSelectors) {\n        const styleElements = getStyleElement(HTML);\n        const scriptElements = getScriptElement(HTML);\n        const styles = [];\n        const scripts = [];\n        let current = styleElements.length;\n        while (current-- > 0) {\n            const style = styleElements[current];\n            const href = getAbsoluteUrl(style, 'href');\n            styles[styles.length] = href;\n            RENDERED_STYLES[href] = style;\n        }\n        current = scriptElements.length;\n        while (current-- > 0) {\n            const script = scriptElements[current];\n            const src = getAbsoluteUrl(script, 'src');\n            scripts[scripts.length] = src;\n            RENDERED_SCRIPTS[script.src] = script;\n        }\n        const startPage = PAGES[CURRENT_PATH];\n        startPage.title = document.title;\n        startPage.styles = styles;\n        startPage.scripts = scripts;\n        startPage.html = START_HTML;\n        START_HTML = null;\n        const { links } = document;\n        current = links.length;\n        while (current-- > 0) {\n            const anchor = links[current];\n            const href = anchor.getAttribute('href');\n            if (!href || !(href.startsWith('./') || href.startsWith('../'))) {\n                continue;\n            }\n            anchor.setAttribute('href', anchor.href);\n        }\n        // @ts-ignore\n        return (route = function (href, htmlSelectors) {\n            // console.debug(`[singular] ${href}`);\n            if (LOADED) {\n                const callbacks = PAGES[CURRENT_PATH].exitCallbacks.concat(UNLOAD_CALLBACKS);\n                const end = callbacks.length;\n                let current = -1;\n                try {\n                    while (++current < end) {\n                        callbacks[current]();\n                    }\n                }\n                catch (reason) {\n                    console.warn(reason);\n                }\n            }\n            else if (FETCH_CONTROLLER) {\n                FETCH_CONTROLLER.abort();\n            }\n            if (!htmlSelectors) {\n                htmlSelectors = CONFIGURE.htmlSelectors;\n            }\n            window.scrollTo(0, 0);\n            document.title = href.substring(href.indexOf(':') + 3);\n            LOADED = false;\n            CURRENT_PATH = getHref(href);\n            const cache = PAGES[CURRENT_PATH];\n            if (cache) {\n                if (CONFIGURE.enableKeepHtml) {\n                    render(cache);\n                }\n                else {\n                    request(href)\n                        .then(html => {\n                        cache.html = html;\n                        render(cache);\n                    });\n                }\n            }\n            else {\n                request(href)\n                    .then(html => {\n                    parse(href, html, htmlSelectors);\n                });\n            }\n        }).apply(this, arguments);\n        function request(href) {\n            FETCH_CONTROLLER = new AbortController();\n            return fetch(href, {\n                signal: FETCH_CONTROLLER.signal\n            })\n                .then(responseText)\n                .catch(catchError);\n        }\n        function responseText(response) {\n            return response.text();\n        }\n        function catchError(reason) {\n            console.warn(reason);\n            if (!(reason instanceof DOMException)) {\n                console.warn(reason);\n            }\n        }\n    }\n    function parse(href, rawHtml, htmlSelectors) {\n        const page = getPage(rawHtml, href, htmlSelectors);\n        PAGES[CURRENT_PATH] = page;\n        render(page);\n    }\n    function getHref(href) {\n        if (!CONFIGURE.enableHashString) {\n            const index = href.indexOf('#');\n            if (index > -1) {\n                href = href.substring(0, index);\n            }\n        }\n        if (!CONFIGURE.enableSearchString) {\n            const searchIndex = href.indexOf('?');\n            const hashIndex = href.indexOf('#');\n            if (searchIndex > -1) {\n                href = (href.substring(0, searchIndex)\n                    + (hashIndex > -1 ?\n                        href.substring(hashIndex) :\n                        ''));\n            }\n        }\n        return href;\n    }\n    function getPage(rawHtml, href, htmlSelectors) {\n        FRAGMENT_HTML.innerHTML = rawHtml;\n        const title = (FRAGMENT_HTML.getElementsByTagName('TITLE')[0] || {}).innerText || href;\n        let current;\n        const { classSelectors } = CONFIGURE;\n        let classMap = null;\n        if (classSelectors) {\n            classMap = {};\n            current = classSelectors.length;\n            while (current-- > 0) {\n                const selector = classSelectors[current];\n                classMap[selector] = (FRAGMENT_HTML.getElementsByTagName(selector)[0] || {}).className || '';\n            }\n        }\n        const styleElements = getStyleElement(FRAGMENT_HTML);\n        const scriptElements = getScriptElement(FRAGMENT_HTML);\n        const styles = getStyleHref(styleElements);\n        const scripts = getScriptSrc(scriptElements);\n        current = scriptElements.length;\n        while (current-- > 0) {\n            const script = scriptElements[current];\n            if (script?.parentNode) {\n                script.parentNode.removeChild(script);\n            }\n        }\n        let html;\n        if (htmlSelectors) {\n            const targetHTML = [];\n            let current = htmlSelectors.length;\n            while (current-- > 0) {\n                const target = FRAGMENT_HTML.querySelector('#' + htmlSelectors[current]);\n                if (target) {\n                    targetHTML[targetHTML.length] = target.outerHTML;\n                }\n            }\n            html = targetHTML.join('');\n        }\n        else {\n            html = FRAGMENT_HTML.outerHTML;\n        }\n        const page = new Page;\n        page.title = title;\n        page.title = title;\n        page.styles = styles;\n        page.scripts = scripts;\n        page.classes = classMap;\n        page.html = html;\n        return page;\n    }\n    function render(page) {\n        const { title, styles, scripts, classes, html } = page;\n        if (title) {\n            document.title = title;\n        }\n        const { htmlSelectors, classSelectors } = CONFIGURE;\n        if (classSelectors && classes) {\n            let current = classSelectors.length;\n            while (current-- > 0) {\n                const selector = classSelectors[current];\n                const target = HTML.querySelector(selector);\n                if (target) {\n                    target.className = classes[selector];\n                }\n            }\n        }\n        FRAGMENT_HTML.innerHTML = html;\n        if (htmlSelectors) {\n            let current = htmlSelectors.length;\n            while (current-- > 0) {\n                const selector = htmlSelectors[current];\n                const from = FRAGMENT_HTML.querySelector('#' + selector);\n                const to = BODY.querySelector('#' + selector);\n                if (from && to) {\n                    const parent = to.parentNode;\n                    parent.replaceChild(from, to);\n                }\n            }\n        }\n        else {\n            BODY.innerHTML = '';\n            BODY.append(...(FRAGMENT_HTML.getElementsByTagName('BODY')[0]\n                || FRAGMENT_HTML).children);\n        }\n        FRAGMENT_HTML.innerHTML = '';\n        const { addScript, addStyle } = singular;\n        const elements = [];\n        const imports = [Promise.resolve()];\n        const removeStyles = [];\n        let end;\n        let current;\n        if (!CONFIGURE.enableKeepStyles) {\n            const renderedStyleHrefs = Object.keys(RENDERED_STYLES);\n            current = renderedStyleHrefs.length;\n            while (current-- > 0) {\n                let href = renderedStyleHrefs[current];\n                if (styles.indexOf(href) > -1) {\n                    continue;\n                }\n                // RENDERED_STYLES[href].disabled = true;\n                removeStyles[removeStyles.length] = RENDERED_STYLES[href];\n                delete RENDERED_STYLES[href];\n            }\n        }\n        // add external stylesheet\n        end = styles.length;\n        current = -1;\n        while (++current < end) {\n            const href = styles[current];\n            if (RENDERED_STYLES[href]) {\n                //     RENDERED_STYLES[href].disabled = false;\n                continue;\n            }\n            const { link, promise } = addStyle(href);\n            RENDERED_STYLES[href] = link;\n            imports[imports.length] = promise;\n            elements[elements.length] = link;\n        }\n        // add external script\n        end = scripts.length;\n        current = -1;\n        while (++current < end) {\n            const src = scripts[current];\n            if (RENDERED_SCRIPTS[src]) {\n                continue;\n            }\n            const { script, promise } = addScript(src);\n            RENDERED_SCRIPTS[src] = script;\n            imports[imports.length] = promise;\n            elements[elements.length] = script;\n        }\n        if (elements.length) {\n            HEAD.append(...elements);\n        }\n        Promise.all(imports)\n            .then(() => {\n            let current = removeStyles.length;\n            while (current-- > 0) {\n                const link = removeStyles[current];\n                link.parentNode.removeChild(link);\n            }\n            onLoad();\n        });\n    }\n    function getStyleElement(container) {\n        const result = [];\n        const styles = FROM(container.querySelectorAll('link[rel=stylesheet]'));\n        const end = styles.length;\n        let current = -1;\n        while (++current < end) {\n            const link = styles[current];\n            if (link.getAttribute('href') && link.href.startsWith(ORIGIN)) {\n                result[result.length] = link;\n            }\n        }\n        return result;\n    }\n    function getStyleHref(styles) {\n        const result = [];\n        let current = styles.length;\n        while (current-- > 0) {\n            result[result.length] = getAbsoluteUrl(styles[current], 'href');\n        }\n        return result;\n    }\n    function getScriptElement(container) {\n        const result = [];\n        const scripts = container.querySelectorAll('script[src]');\n        const end = scripts.length;\n        let current = -1;\n        while (++current < end) {\n            const script = scripts[current];\n            if (script.getAttribute('src') && script.src.startsWith(ORIGIN)) {\n                result[result.length] = script;\n            }\n        }\n        return result;\n    }\n    function getScriptSrc(scripts) {\n        const result = [];\n        let current = scripts.length;\n        while (current-- > 0) {\n            result[result.length] = getAbsoluteUrl(scripts[current], 'src');\n        }\n        return result;\n    }\n    function getAbsoluteUrl(node, attribute) {\n        return '' + (new URL(node.getAttribute(attribute), CURRENT_PATH));\n    }\n    function onLoad() {\n        // console.debug('[singular] before load');\n        const end = SERIES_CALLBACKS.length;\n        let current = -1;\n        let series = Promise.resolve();\n        while (++current < end) {\n            const callback = SERIES_CALLBACKS[current];\n            series = series.then(() => callback());\n        }\n        const prepares = [series];\n        current = PARALLEL_CALLBACKS.length;\n        while (current-- > 0) {\n            prepares[prepares.length] = PARALLEL_CALLBACKS[current]();\n        }\n        SERIES_CALLBACKS = [];\n        PARALLEL_CALLBACKS = [];\n        Promise.all(prepares)\n            .then(onLoading)\n            .catch(catchReload);\n    }\n    function onLoading() {\n        // console.debug('[singular] after load');\n        HTML.style.visibility = 'inherit';\n        try {\n            onLoaded();\n        }\n        catch (reason) {\n            console.warn(reason);\n        }\n    }\n    function catchReload(reason) {\n        console.warn(reason);\n        if (!CONFIGURE.development) {\n            location.reload();\n        }\n    }\n    function onLoaded(changedElement = BODY) {\n        // console.debug('[singular] Loaded');\n        LOADED = true;\n        const store = PAGES[CURRENT_PATH];\n        const callbacks = [\n            ...READY_CALLBACKS.splice(0, READY_CALLBACKS.length),\n            ...LOAD_CALLBACKS,\n            ...store.enterCallbacks\n        ];\n        const end = callbacks.length;\n        let current = -1;\n        while (++current < end) {\n            callbacks[current](changedElement);\n        }\n    }\n    addEventListener('click', function onClick(event) {\n        let node = event.target;\n        const { tagName } = node;\n        if (tagName === 'BODY') {\n            return false;\n        }\n        if (tagName !== 'A') {\n            if (node?._singularAnchor === false) {\n                return true;\n            }\n            const anchor = node.closest('a');\n            if (!anchor || !anchor.href) {\n                node._singularAnchor = false;\n                return true;\n            }\n            node = anchor;\n        }\n        const { href } = node;\n        const rawHref = node.getAttribute('href');\n        if (!href.startsWith(ORIGIN)\n            || node.download\n            || (rawHref && rawHref.startsWith('#'))) {\n            node._singularAnchor = false;\n            return true;\n        }\n        node._singularAnchor = node;\n        const inlineOutlet = node?.dataset?.outlet;\n        singular.route(node.href, inlineOutlet ? inlineOutlet.split(',') : undefined);\n        event.stopPropagation();\n        event.preventDefault();\n        return false;\n    });\n    addEventListener('popstate', function onPopstate(event) {\n        const { state } = event;\n        if (state && state.singular) {\n            route(state.singular.href);\n        }\n        return true;\n    });\n    addEventListener('DOMContentLoaded', function onDOMContentLoaded() {\n        HTML = document.documentElement;\n        HEAD = document.head;\n        BODY = document.body;\n        START_HTML = HTML.outerHTML;\n        CURRENT_PATH = getHref(START_PATH);\n        if (CURRENT_PATH !== START_PATH) {\n            PAGES[CURRENT_PATH] = PAGES[START_PATH];\n            delete PAGES[START_PATH];\n        }\n        HTML.style.visibility = 'hidden';\n        onLoad();\n    });\n    return singular;\n})(window, document);\n"]}